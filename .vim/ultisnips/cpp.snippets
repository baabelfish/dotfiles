snippet cenum "" !w
enum class ${1:Name} {
    $0
};
endsnippet

snippet new "" !w
${1:int}* ${2:magic} = new $1(${3});$0
endsnippet

snippet qd "" !w
qDebug() << $0;
endsnippet

snippet case "" !w
case ${1}:$0
    break;
endsnippet

snippet qmain "" !w
#include <QApplication>

int main(int argc, char* argv[]) {
    QApplication app(argv, args);$0
    return app.exec();
}
endsnippet

snippet cin "" !w
std::cin >> ${1:variable};$0
endsnippet

snippet timer "" !w
using namespace std::chrono;
high_resolution_clock::time_point t_start = high_resolution_clock::now();
${VISUAL}
high_resolution_clock::time_point t_stop = high_resolution_clock::now();
double time = duration_cast<duration<double>>(t_stop - t_start).count();
endsnippet

snippet strsplit "" !w
std::istringstream iss(${1:str});
std::${2:vector}<std::string> tokens;
std::copy(std::istream_iterator<std::string>(iss),
        std::istream_iterator<std::string>(),
        std::back_inserter<std::$2<std::string>>(tokens));$0
endsnippet

snippet try "" !w
try {
    ${VISUAL}$0
}
catch ($1) {
    $2
}
catch (...) {
}
endsnippet

snippet sort "" !w
std::sort(${1:container}.begin(), $1.end()${2});$0
endsnippet

snippet lambda "" !w
[${1:&}](${2})${3: mutable} -> ${4:bool} {$0
};
endsnippet

snippet utfile "Unit test file template" !w
#include <utest/utest.hpp>

TEST("${1:name}") {
    $0
}

EXEC()
endsnippet

snippet uttest "" !w
TEST("${1:name}") {
    $0
}
endsnippet

snippet utassert "" !w
ASSERT(${1:true}, "${2}");$0
endsnippet

snippet utcheck "" !w
CHECK(${1:true}, "${2}");$0
endsnippet

snippet utwarning "" !w
WARNING(${1:true}, "${2}");$0
endsnippet

snippet ansicolor "" !w
\033[$1m$0
endsnippet

snippet ansiclear "" !w
\033[1;1H\033[2J$0
endsnippet

snippet ansi "" !w
\033[$0
endsnippet

snippet mapi "" !w
std::pair<std::${1:map}<${2:int}, ${3:int}>::iterator, bool> ${4:nit};
$4 = ${5:mymap}.insert(std::pair<$2, $3>($6, $7));
if (!$4.second) {
    $0
}
endsnippet

snippet { "" !w
{
    $0
}
endsnippet

snippet deque "" !w
std::deque<$1> $2;$0
endsnippet

snippet map "" !
std::map<$1, $2> $3;$0
endsnippet

snippet macro "" !w
#define ${1:name}($2)\
    $0
endsnippet

snippet qtmainwindowhpp "" !
#pragma once

#include <QMainWindow>

class MainWindow : public QMainWindow
{
    Q_OBJECT
    
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    
private:
};
endsnippet

snippet sc "static_cast" !w
static_cast<${1:int}>(${VISUAL}$2)$0
endsnippet

snippet wstr "" !w
std::wstring ${1:wstr}
endsnippet

snippet str "" !w
std::string ${1:str}
endsnippet

snippet cstr "" !w
const std::string& ${1:str}
endsnippet

snippet qtmainwindowcpp "" !
#include "mainwindow.hpp"

MainWindow::MainWindow(QWidget *parent):
    QMainWindow(parent)
{
}

MainWindow::~MainWindow()
{
}
endsnippet

snippet once "pragma" !
#pragma once

$0
endsnippet

snippet switch "" !
switch ($1) {
    case $2:
        break;$0
    default:
        break;
}
endsnippet

snippet main "" !
int main(int argc, char* argv[]) {
    $0
    return 0;
}
endsnippet

snippet incu "include user file" !
#include "${1:file}"$0
endsnippet

snippet incl "include library" !
#include <${1:iostream}>$0
endsnippet

snippet templatefunc "Template function" !
template <class T>
${1:T} ${2:name}(${3:T value}) {
    $0
}
endsnippet

snippet wcout "Basic output for easy use" !
std::wcout << ${VISUAL}$1 << std::endl;$0
endsnippet

snippet wcerr "Basic output for easy use" !
std::wcerr << ${VISUAL}$1 << std::endl;$0
endsnippet

snippet cout "Basic output for easy use" !
std::cout << ${VISUAL}$1 << std::endl;$0
endsnippet

snippet cerr "Basic output for easy use" !
std::cerr << ${VISUAL}$1 << std::endl;$0
endsnippet

snippet func "Function" !
$1${2:void} ${3:name}($4) {
    $0
}
endsnippet

snippet while "While loop" !
while (${1}) {
    ${VISUAL}$0
}
endsnippet

snippet struct "Basic struct" !
struct ${1:Name} {
    $0
};
endsnippet

snippet tclass "Template class template" !
template <typename ${1:T}>
class ${2:Name}$3 {
public:
    $2($1 data);
    virtual ~$2();

private:
    $0
};
endsnippet

snippet class "Class template" !
class ${1:Name} ${2}{
public:
    $1();
    virtual ~$1();

private:
    $0
};
endsnippet

snippet namespace "" !
namespace ${1:Name} {$0
} // namespace $1
endsnippet

snippet for "C++11 auto for loop" !
for (std::size_t ${1:i} = ${2:0}; $1 < ${3:value}; ${4:++$1}) {
    ${VISUAL}$0
}
endsnippet

snippet fore "C++11 foreach loop" !
for (auto& ${1:x} : ${2:container}) {
    ${VISUAL}$0
}
endsnippet

snippet forp "C++ pointer for loop" !
for (${1:Type}* ${2:i} = ${3}; $2 != nullptr; $2 = ${4:next}) {$0
}
endsnippet

snippet if "" !w
if (${1}) {
    ${VISUAL}$0
}
endsnippet

snippet else "" !w
else {
    ${VISUAL}$0
}
endsnippet

snippet lisence_mit "MIT lisence" !
/**
  * Copyright (C) ${1:2012} ${2:Niko Junkala}
  * 
  * Permission is hereby granted, free of charge, to any person obtaining a copy of
  * this software and associated documentation files (the "Software"), to deal in
  * the Software without restriction, including without limitation the rights to
  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  * the Software, and to permit persons to whom the Software is furnished to do so,
  * subject to the following conditions:
  * 
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  * 
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
$0
endsnippet
